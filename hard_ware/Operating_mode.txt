按照 CPU 功能升级迭代的顺序，CPU 的工作模式有实模式、保护模式、长模式，这几种工作模式下 CPU 执行程序的方式截然不同
实模式：
    实模式又称实地址模式，实，即真实，这个真实分为两个方面，一个方面是运行真实的指令，对指令的动作不作区分，直接执行指令的真实功能，另一方面是发往内存的地址是真实的，对任何地址不加限制地发往内存。
    x86 CPU 在实模式下的寄存器。表中每个寄存器都是 16 位的。
        寄存器                  描述
    AX BX CX DX DI SI BP    通用寄存器，里面可以存放数据、地址参与运算
    IP                      程序指针寄存器，指向下一条指令的地址
    SP                      栈指针寄存器，指向栈顶
    CS DS ES SS             段寄存器，代码段、数据段、堆栈段
    FLAGS                   CPU寄存器标志，存放CPU执行运算指令产生的状态位

    分段内存管理模型：
    内存地址：由段寄存器左移 4 位，再加上一个通用寄存器中的值或者常数形成地址，然后由这个地址去访问内存。
    取指 地址计算：CS << 4 + IP
    取数据 地址计算：DS ES SS + AX BX CX DX EX DI SI BP SP

    中断：
        中断即中止执行当前程序，转而跳转到另一个特定的地址上，去运行特定的代码。在实模式下它的实现过程是先保存 CS 和 IP 寄存器，然后装载新的 CS 和 IP 寄存器
        硬中断：中断控制器给 CPU 发送了一个电子信号，CPU 会对这个信号作出应答。随后中断控制器会将中断号发送给 CPU
        软中断：CPU 执行了 INT 指令，这个指令后面会跟随一个常数，这个常数即是软中断号
        无论是硬件中断还是软件中断，都是 CPU 响应外部事件的一种方式。
        为了实现中断，就需要在内存中放一个中断向量表，这个表的地址和长度由 CPU 的特定寄存器 IDTR 指向。实模式下，表中的一个条目由代码段地址和段内偏移组成
        有了中断号以后，CPU 就能根据 IDTR 寄存器中的信息，计算出中断向量中的条目，进而装载 CS（装入代码段基地址）、IP（装入代码段内偏移）寄存器，最终响应中断
保护模式：
    保护模式下寄存器：
        保护模式相比于实模式，增加了一些控制寄存器和段寄存器，扩展通用寄存器的位宽，所有的通用寄存器都是 32 位的，还可以单独使用低 16 位，这个低 16 位又可以拆分成两个 8 位寄存器
                寄存器                  描述
        EAX EBX ECX EDX EDI ESI EBP 32位通用寄存器，可以存放数据、地址、参与运算
                EIP                 32位程序指针寄存器，始终指向下一条指令地址
                ESP                 栈指针寄存器，指向栈顶
        CS DS ES SS FS GS           16位段寄存器，存放内存段的描述符索引
                EFLAGS              32位CPU标志寄存器，存放cpu执行指令的状态位
        CR0 CR1 CR2 CR3             32位cpu控制寄存器，控制cpu的功能控制特性，如开启保护模式等
    
    保护模式特权级：
        为了区分哪些指令(in, out,cli)和哪些资源(寄存器、IO端口、内存地址)可以被访问，CPU实现了特权级
        特权级分为 4 级，R0~R3，每个特权级执行指令的数量不同，R0 可以执行所有指令，R1、R2、R3 依次递减，它们只能执行上一级指令数量的子集。而内存的访问则是靠后面所说的段描述符和特权级相互配合去实现的
    
    段描述符：
        一个段描述符有 64 位 8 字节数据，里面包含了段基地址、段长度、段权限、段类型（可以是系统段、代码段、数据段）、段是否可读写，可执行等。虽然数据分布有点乱，这是由于历史原因造成的
        多个段描述符在内存中形成全局段描述符表，该表的基地址和长度由 CPU 和 GDTR 寄存器指示。
        段寄存器中不再存放段基地址，而是具体段描述符的索引，访问一个内存地址时，段寄存器中的索引首先会结合 GDTR 寄存器找到内存中的段描述符，再根据其中的段信息判断能不能访问成功
    
    段选择子：
        段寄存器是由影子寄存器、段描述符索引、描述符表索引、权限级别组成的
        79-----------------------------16 15-------------3 2 1--0
                影子寄存器                    段描述符索引  TI  RPL
        影子寄存器：缓存具体对应的段描述符
        段描述符索引：从GDT或LDT中查找段描述符
        TI：描述符表索引，0---从GDT表查找，1----从LDT表查找
        RPL:请求访问者所用的访问权限

        影子寄存器是靠硬件来操作的，对系统程序员不可见，是硬件为了减少性能损耗而设计的一个段描述符的高速缓存，不然每次内存访问都要去内存中查表，那性能损失是巨大的，影子寄存器也正好是 64 位，里面存放了 8 字节段描述符数据
        低三位之所以能放 TI 和 RPL，是因为段描述符 8 字节对齐，每个索引低 3 位都为 0
        通常情况下，CS 和 SS 中 RPL 就组成了 CPL（当前权限级别），所以常常是 RPL=CPL，进而 CPL 就表示发起访问者要以什么权限去访问目标段，当 CPL 大于目标段 DPL 时，则 CPU 禁止访问，只有 CPL 小于等于目标段 DPL 时才能访问

    平坦模型：
        分段模型有很多缺陷，这在后面课程讲内存管理时有详细介绍，其实现代操作系统都会使用分页模型
        但是 x86 CPU 并不能直接使用分页模型，而是要在分段模型的前提下，根据需要决定是否要开启分页。因为这是硬件的规定，程序员是无法改变的。但是我们可以简化设计，来使分段成为一种“虚设”，这就是保护模式的平坦模型
        我们发现 CPU32 位的寄存器最多只能产生 4GB 大小的地址，而一个段长度也只能是 4GB，所以我们把所有段的基地址设为 0，段的长度设为 0xFFFFF，段长度的粒度设为 4KB，这样所有的段都指向同一个（（段的长度 +1）* 粒度 - 1）字节大小的地址空间。
        表示0xFFFFF个4KB内存空间，即4GB（）
    中断：
        保护模式下的中断要权限检查，还有特权级的切换，所以就需要扩展中断向量表的信息，即每个中断用一个中断门描述符来表示，也可以简称为中断门
        中断向量表，同样是由 IDTR 寄存器指向，只不过中断向量表中的条目变成了中断门描述符
        产生中断后，CPU 首先会检查中断号是否大于最后一个中断门描述符，x86 CPU 最大支持 256 个中断源（即中断号：0~255），然后检查描述符类型（是否是中断门或者陷阱门）、是否为系统描述符，是不是存在于内存中
        接着，检查中断门描述符中的段选择子指向的段描述符
        最后做权限检查，如果 CPL 小于等于中断门的 DPL，并且 CPL 大于等于中断门中的段选择子所指向的段描述符的 DPL，就指向段描述符的 DPL。CPL 小于等于中断门的 DPL，说明有权限能执行中断。 CPL 大于等于所指向的段描述符的 DPL，如果不提升 CPL，就会导致没有权限调到该内存，所以指向段描述符的 DPL。
        进一步的，CPL 等于中断门中的段选择子指向段描述符的 DPL，则为同级权限不进行栈切换，否则进行栈切换。如果进行栈切换，还需要从 TSS 中加载具体权限的 SS、ESP，当然也要对 SS 中段选择子指向的段描述符进行检查
        做完这一系列检查之后，CPU 才会加载中断门描述符中目标代码段选择子到 CS 寄存器中，把目标代码段偏移加载到 EIP 寄存器中
    切换到保护模式：
        x86 CPU 在第一次加电和每次 reset 后，都会自动进入实模式，要想进入保护模式，就需要程序员写代码实现从实模式切换到保护模式。
        第一步，准备全局段描述符表
        第二步，加载设置 GDTR 寄存器，使之指向全局段描述符表。
        第三步，设置 CR0 寄存器，开启保护模式
        第四步，进行长跳转，加载 CS 段寄存器，即段选择子。
            为什么要进行长跳转，这是因为我们无法直接或间接 mov 一个数据到 CS 寄存器中，因为刚刚开启保护模式时，CS 的影子寄存器还是实模式下的值，所以需要告诉 CPU 加载新的段信息
长模式：
    长模式相比于保护模式，增加了一些通用寄存器，并扩展通用寄存器的位宽，所有的通用寄存器都是 64 位，还可以单独使用低 32 位。这个低 32 位可以拆分成一个低 16 位寄存器，低 16 位又可以拆分成两个 8 位寄存器
            寄存器                                                  描述
    RAX RBX RCX RDX RDI RSI RBP R8~R15                          64位通用寄存器，可以存放数据、地址、参与运算
            RIP                                                 64位程序指针寄存器，指向下一条指令地址
            RSP                                                 栈指针寄存器，指向栈顶
    CS DS ES SS FS GS                                           16位段寄存器，存放段描述符索引
            FLAGS                                               64位标志寄存器，存放执行CPU指令产生的状态位
    CR0 CR1 CR2 CR3 CR4                                         除了CR0是32位控制寄存器，其他都是64位寄存器
    
    长模式段描述符：
        在长模式下，CPU 不再对段基址和段长度进行检查

1. 实模式，早期 CPU 是为了支持单道程序运行而实现的，单道程序能掌控计算机所有的资源，早期的软件规模不大，内存资源也很少，所以实模式极其简单，仅支持 16 位地址空间，分段的内存模型，对指令不加限制地运行，对内存没有保护隔离作用。
2. 保护模式，随着多道程序的出现，就需要操作系统了。内存需求量不断增加，所以 CPU 实现了保护模式以支持这些需求。保护模式包含特权级，对指令及其访问的资源进行控制，对内存段与段之间的访问进行严格检查，没有权限的绝不放行，对中断的响应也要进行严格的权限检查，扩展了 CPU 寄存器位宽，使之能够寻址 32 位的内存地址空间和处理 32 位的数据，从而 CPU 的性能大大提高。
3. 长模式，又名 AMD64 模式，最早由 AMD 公司制定。由于软件对 CPU 性能需求永无止境，所以长模式在保护模式的基础上，把寄存器扩展到 64 位同时增加了一些寄存器，使 CPU 具有了能处理 64 位数据和寻址 64 位的内存地址空间的能力。长模式弱化段模式管理，只保留了权限级别的检查，忽略了段基址和段长度，而地址的检查则交给了 MMU